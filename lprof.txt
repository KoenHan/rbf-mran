Timer unit: 1e-06 s

Total time: 15.5956 s
File: /home/han/catkin_ws/src/rbf_mran/RBF_MRAN.py
Function: update_rbf at line 127

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   127                                               @profile
   128                                               def update_rbf(self, input, yi):
   129      4999    1738398.0    347.7     11.1          f = self._rbf.calc_f(input)
   130      4999     270305.0     54.1      1.7          o = self._rbf.calc_o()
   131                                           
   132                                                   # Step 1
   133      4999    1556755.0    311.4     10.0          satisfied, ei, ei_norm, di = self._calc_error_criteria(input, f, yi)
   134                                                   # print("satisfied case ", satisfied)
   135      4999      22776.0      4.6      0.1          z = self._rbf.get_param_num()
   136      4999       4333.0      0.9      0.0          if satisfied == 0 :
   137                                                       # print("satisfied!!!")
   138                                                       # Step 2
   139        18        110.0      6.1      0.0              self._rbf.add_hidden_unit(ei, input, self._kappa*di)
   140                                           
   141                                                       # Pの拡張
   142        18         68.0      3.8      0.0              zeros = np.zeros((z, self._z1), dtype=np.float64)
   143        18        381.0     21.2      0.0              self._P = np.hstack([self._P, zeros])
   144        18         24.0      1.3      0.0              tmp = zeros.T
   145        18        473.0     26.3      0.0              tmp = np.hstack([tmp, self._p0*np.eye(self._z1)])
   146        18        277.0     15.4      0.0              self._P = np.vstack([self._P, tmp])
   147                                                   else :
   148                                                       # print("not satisfied!!!")
   149                                                       # Step 3
   150      4981    4931005.0    990.0     31.6              PI = self._rbf.calc_PI()
   151                                                       # Step 4
   152      4981    1616009.0    324.4     10.4              chi = self._rbf.gen_chi()
   153      4981     237068.0     47.6      1.5              K = self._P@PI@np.linalg.inv(self._R + PI.T@self._P@PI)
   154      4981      24101.0      4.8      0.2              chi = chi + K@ei
   155      4981     170418.0     34.2      1.1              self._rbf.update_param_from_chi(chi)
   156                                           
   157                                                       # Pの更新
   158      4981      66091.0     13.3      0.4              I = np.eye(z)
   159      4981    3222088.0    646.9     20.7              self._P = (I - K@PI.T)@self._P + self._q*I
   160                                                       # self._P = (I - K@PI.T)@self._P + random.uniform(0, 0.1)*I # todo: 勾配方向のランダムステップの実装
   161                                           
   162                                                   # Step 5
   163      4999       5850.0      1.2      0.0          if o is not None:
   164      4998    1616134.0    323.4     10.4              pruned_unit = self._rbf.prune_unit(o, self._Sw, self._delta)
   165                                                       # Pの調整
   166      4999       5942.0      1.2      0.0              for ui in pruned_unit:
   167         1          2.0      2.0      0.0                  start = self._rbf_ny + self._z1*ui
   168         2         26.0     13.0      0.0                  self._P = np.delete(
   169         1         53.0     53.0      0.0                      np.delete(self._P, slice(start, start+self._z1), 0),
   170         1          2.0      2.0      0.0                      slice(start, start+self._z1), 1)
   171                                           
   172                                                   # 更新が終わったのでインクリメント
   173      4999       7127.0      1.4      0.0          self._cnt_train_num += 1
   174                                           
   175                                                   # 学習中の誤差（式3.16）の算出及び保存
   176                                                   # self._ei_abs.append(ei_norm)
   177                                                   # if len(self._ei_abs) >= self._Nw:
   178                                                   #     self._Id_hist.append(sum(self._ei_abs[-self._Nw:])/self._Nw)
   179      4999       5462.0      1.1      0.0          idx = self._ei_abs_idx%self._Nw
   180      4999       7692.0      1.5      0.0          self._ei_abs_sum -= self._ei_abs[idx]
   181      4999       4817.0      1.0      0.0          self._ei_abs_sum += ei_norm
   182      4999       4464.0      0.9      0.0          self._ei_abs[idx] = ei_norm
   183      4999       5147.0      1.0      0.0          self._ei_abs_idx += 1
   184      4999       4722.0      0.9      0.0          if self._ei_abs_idx >= self._Nw :
   185      4952      11363.0      2.3      0.1              self._Id_hist.append(self._ei_abs_sum/self._Nw)
   186                                                   # 学習中の隠れニューロン数保存
   187      4999      11962.0      2.4      0.1          self._h_hist.append(self._rbf.get_h())
   188                                                   # 学習全体のMAEの計算のために合計を取る
   189      4999       5164.0      1.0      0.0          self._total_MAE += ei_norm
   190                                           
   191                                                   # 履歴の逐次保存
   192      4999      35047.0      7.0      0.2          self.save_res()
   193                                           
   194      4999       3923.0      0.8      0.0          return f

